<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>ChenHan&#39;s Tech blog </title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="description" content="" />

<meta name="keywords" content="">


<meta property="og:title" content="ChenHan&#39;s Tech blog ">
<meta property="og:site_name" content="ChenHan&#39;s Tech blog"/>
<meta property="og:url" content="https://swem.github.io/" />
<meta property="og:locale" content="en-us">


<meta property="og:type" content="website" />



<link href="https://swem.github.io/index.xml" rel="alternate" type="application/rss+xml" title="ChenHan&#39;s Tech blog" />

<link rel="canonical" href="https://swem.github.io/" />

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://swem.github.io/touch-icon-144-precomposed.png">
<link href="https://swem.github.io/favicon.png" rel="icon">

<meta name="generator" content="Hugo 0.22.1" />

  
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link href='https://fonts.googleapis.com/css?family=Merriweather:300%7CRaleway%7COpen+Sans' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="https://swem.github.io/css/font-awesome.min.css">
<link rel="stylesheet" href="https://swem.github.io/css/style.css">
<link rel="stylesheet" href="https://swem.github.io/css/highlight/default.css">

  
  
</head>
<body>
  <main id="main-wrapper" class="container main_wrapper has-sidebar">
    <header id="main-header" class="container main_header">
  <div class="container brand">
  <div class="container title h1-like">
  <a class="baselink" href="https://swem.github.io/">
  Chen-Han (Stanley) Hsiao

</a>

</div>

  
<div class="container topline">
  
  ChenHan&rsquo;s Tech blog


</div>


</div>

  <nav class="container nav primary no-print">
  


  
<a href="https://swem.github.io/about">About</a>

<a href="https://swem.github.io/post" title="Show list of posts">Posts</a>

<a href="https://swem.github.io/tags" title="Show list of tags">Tags</a>


</nav>

<div class="container nav secondary no-print">
  


<a id="contact-link-github" class="contact_link" href="https://github.com/swem">
  <span class="fa fa-github-square"></span><span>github</span></a>





<a id="contact-link-linkedin" class="contact_link" href="https://www.linkedin.com/in/chen-han-hsiao-2b486049">
  <span class="fa fa-linkedin-square"></span><span>linkedin</span></a>



















</div>


  

</header>


<section id="main-content" class="container main_content homepage">
  <header class="container header">
    <h1>ChenHan&#39;s Tech blog
</h1>

    <span>last update: <time datetime="2017-07-01T23:35:17&#43;08:00">1 July at 11:35pm</time>
</span>

  </header>
  
  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-05-12-offline-access-for-google-drive/">offline access for google drive
</a>
</h2>

  <time datetime="2013-05-12">12 May, 2013</time>

</div>

  <p class="container content">
  
  
    Google 推出行動硬碟、日曆的離線存取已經有一段時間，我覺得這是個很棒的功能，不過實際使用後才發現有些眉角。 有些使用者安裝了離線版的 Google 行動硬碟、Google 日曆，卻發現仍然沒辦法離線使用
原因出在於 Google 的離線功能需要進行啟用，而且使用者若有多台電腦，則必須為每一台分別開啟離線功能。 你有10台電腦，就要啟用10次。
我想這樣的設計是為了確保使用者的資料是安全的，使用者只在安全的個人電腦上使用離線資料， 不會說在1台電腦上啟用了離線，另外9台也跟著啟用，導致使用者的資料有外洩的可能。
Google 離線啟用的步驟如下，文章最後附上Google 說明連結。
設定離線存取 如要在您的電腦上啟用離線存取功能，請按照下列步驟操作。請注意，離線存取功能只能在 Chrome 中使用。
 按一下畫面左方的 [更多]。 選擇 [Google 文件離線版]。 設定離線存取只需兩個簡單步驟，首先，按一下標示 [啟用 Google 文件離線版] 的藍色按鈕。幾秒鐘後，系統會讓您繼續前往下一個步驟。 在對話框右邊按一下藍色的 [從 Chrome 線上應用程式商店安裝] 按鈕。如果您已經安裝應用程式，則無需完成這個步驟。 之後，系統會將您導向至 Chrome 線上應用程式商店。按一下瀏覽器視窗右上角的 [加到 Chrome]。 應用程式安裝完成後，系統會將您導向 Chrome 頁面，其中會顯示 Google 雲端硬碟應用程式圖示。如要返回雲端硬碟，請按一下 [Google 雲端硬碟] 圖示。  不同檔案類型的存取權 Google 文件和試算表
現在就算沒連上網路，也可以檢視 Google 文件和試算表，甚至可以在離線時編輯 Google 文件。目前使用者還無法在離線狀態下查看 Google 簡報、表單或繪圖。進一步瞭解如何使用 Google 文件離線版。
其他儲存在 Google 雲端硬碟中的檔案
就算您沒連上網際網路，仍可在 Google 雲端硬碟資料夾中查看及編輯檔案 (例如 PDF、Microsoft Office 檔案、圖片)。您在離線時對同步檔案所做的所有變更，都會在重新連上網際網路時與具有時間戳記的所有裝置重新同步處理。
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-05-12-offline-access-for-google-drive/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-05-09-curl-http-redirects/">cURL HTTP redirects
</a>
</h2>

  <time datetime="2013-05-09">9 May, 2013</time>

</div>

  <p class="container content">
  
  
    cURL 是一個 unix 下以命令操作來取得檔案、頁面的工具，在網頁測試中經常使用到。不過要注意的是，cURL 預設並不處理 HTTP 重導向。
昨天在 github 上看到了一個有趣的專案 screenshot-as-a-service，這個專案給使用者的第一個範例就是用 cURL 來進行操作。不過在 Readme.md 裡有點小錯誤。於是我就將它改正過來，並送了一個 Pull Request。 revise usage example in Readme.md
今天發現作者已經將我的 patch 合併進了專案，有興趣的人可以抓下來試一試。
註：現今的網頁設計中，重導向至少有三種。
 HTTP redirects Redirects with HTML tag Redirects with javascript  在 cURL 中，可以下參數讓 cURL 進行第1種 HTTP 重導向。至於第 2, 3 種，cURL 則是完全不支援。原因很簡單，就如同 cURL 最初的設計，是用來取得檔案、頁面用的。它並不是特別用來處理 HTML 的工具，所以這2類重導向就交給其它的工具去處理了。
Ref:
 How do I tell curl to follow HTTP redirects? Redirects work in browser but not with curl!
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-05-09-curl-http-redirects/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-05-08-file-descriptor-in-bash-shell/">File Descriptor in Bash Shell
</a>
</h2>

  <time datetime="2013-05-08">8 May, 2013</time>

</div>

  <p class="container content">
  
  
    一個程式至少會開啟三個Input/Output 串流，分別為
 Standard input (stdin) 標準輸入 Standard output (stdout) 標準輸出 Standard error (stderr) 標準錯誤訊息  操作時相對應的代號就是file descriptor。
在 Bash Shell 中，你最多可以有10個 file descriptor。利用這些 descriptor，你可以結合他們把輸出訊息、錯誤訊息，都導到同一個檔案中，並同時在螢幕上顯示出來。
I/O redirection 的順序性 在進行 I/O redirection 的時候，要注意順序性 (If redirecting both stdout and stderr, the order of the commands makes a difference.)。 以下2個命令是不同的。
$ sh script.sh &gt;log.txt 2&gt;&amp;1 $ sh script.sh 2&gt;&amp;1 &gt;log.txt  -第1個命令，將stdout 導向 log.txt，然後stderr 導向 stdout。如此一來，stderr 也將導入 log.txt。 -第2個命令，將stderr 導向 stdout，然後原先的stdout 導向 log.
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-05-08-file-descriptor-in-bash-shell/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-05-05-git-submodule/">git submodule
</a>
</h2>

  <time datetime="2013-05-05">5 May, 2013</time>

</div>

  <p class="container content">
  
  
    我們可以透過 git submodule 來組合眾多小專案、函式庫，形成一個大專案。這樣的流程特別常見於應用程式依賴於底層的Library時。 (例如Web App 可能會想要引用 facebook-ios-sdk)
使用 git submodule 要先掌握2件事
 git 使用 .gitmodules 來對應小專案、函式庫於大專案中的資料夾位置。 每個開發者可以自行管理要不要取出各個小專案，每個小專案的設定將被註冊在 .git/config  ##Add submodule
git submodule add /path/to/library library/position/in/my_project  ##Check-out submodule
其它協同開發者在大專案中準備取出小專案前，需要先 init, 把小專案的路徑依 .gitmodule 的內容，註冊到自己的 .git/config (如此，git 才知道怎麼去取出、更新小專案)
git submodule init  之後就可以開始更新小專案了。
git submodule update  或是加入 &ndash;recursive 參數，把小專案中的小專案也一併取出來
git submodule update --recursive  ##Remove submodule 移除 submodule 時，修改 .gitmodules 的內容，將欲刪除的 submodule 設定刪掉，並將大專案中的小專案資料夾刪去。再 commit 即可。
# use vim to edit .
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-05-05-git-submodule/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-05-01-git-subtree-merge-strategy/">git subtree merge strategy
</a>
</h2>

  <time datetime="2013-05-01">1 May, 2013</time>

</div>

  <p class="container content">
  
  
    最近工作上遇到一個問題，我們希望在自己的專案中保有專案所依賴的函式庫，而不隨著函式庫的版本更新而變動。例如我們也許想使用 boost 1.5.3 做為我們的依賴函式庫，未來等 boost 改版到 1.6 以後，也許先不急著更換，等到時機恰當再做更換。
在專案中保有的函式庫，檔案結構如：
project ├── lib │ └── boost └── src └── test.cpp  對於這樣的開發需求，我們可以採用 git 裡的 subtree 來幫助我們做到這件事。
** A. 將 lib 併入專案 **
$ git remote add -f boost /path/to/boost $ git merge -s ours --no-commit boost/master $ git read-tree --prefix=lib/boost/ -u boost/master $ git commit -m &quot;Merge boost as our subdirectory&quot;  ** B. 導入 lib 更新 **
$ rm -rf lib/project1 $ git add -u $ git merge -s ours --no-commit boost/master $ git read-tree --prefix=lib/boost/ -u boost/master $ git commit -m &quot;Merge boost as our subdirectory&quot;  之所以採用 git subtree，而不採用 git submodule。是因為 git submodule 的更新原則基本上是會更新到最新的版本，以我們的開發需求並不適用。
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-05-01-git-subtree-merge-strategy/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-04-24-npm-install/">npm install
</a>
</h2>

  <time datetime="2013-04-24">24 Apr, 2013</time>

</div>

  <p class="container content">
  
  
    NPM (Node Packaged Modules) 是 Node.js 裡很好用的模組安裝工具。從 npm 1.0 開始，有兩個方式來安裝模組。
 全域安裝，通常會把模組安裝在 /usr/local/lib/node_modules 的位置。
$ npm install -g express  專案資料夾內的安裝，
$ npm install express   如何決定要用什麼方式來安裝呢。Node.js 提供了以下的原則：
 如果你要安裝的模組是用在專案中，以 require(&lsquo;whatever&rsquo;) 的方式來引用。那麼就在專案的資料夾安裝 如果你安裝的模組是要在 shell 裡使用的，那麼就用全域安裝。  不過，有些模組你既需要在專案中 require 它，也需要在 shell 中執行它所附加的小工具。像是常用的Coffee-script、Express。 那該怎麼做比較好呢。我建議你在全域還有專案資料夾內各安裝一份，這樣子很簡單也容易維護。
P.S. 你可以用 npm -v 來確定自己的 npm 是否為1.0 以上的版本。
Ref: npm 1.0: Global vs Local installation
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-04-24-npm-install/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-04-23-code-school-hall-passes/">Code School Hall Passes
</a>
</h2>

  <time datetime="2013-04-23">23 Apr, 2013</time>

</div>

  <p class="container content">
  
  
    Code School 現在可以啟用兩天完全免費的課程 Code School - Hall Pass
目前他們的商業模式是少部份課程免費，其餘課程要成為收費會員才能上課，1個月 25 美元。 大多是 Web development 相關，課程的品質很好，對初學者很好上手，有興趣的人可以試一試。
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-04-23-code-school-hall-passes/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-04-10-digitalocean/">DigitalOcean 初體驗
</a>
</h2>

  <time datetime="2013-04-10">10 Apr, 2013</time>

</div>

  <p class="container content">
  
  
    前幾天剛好有虛擬機器的需要，所以上 DigitalOcean 開了一台最便宜的來試試。
架設 Server 十分容易，方案選一下，信用卡開下去就有了。 設備：512MB Memory, 1 Core, 20GB SSD Disk, 1TB Transfer
我選在 New York 的 Data Center，從台灣連過去的 Latency 大約是230ms。差強人意，但以我的用途可接受。 使用12小時花了 $0.09 美元，實在是非常划算。
後來因為用不到了，所以把機器做了個 Snapshot，然後就把機器刪除了。 這樣就不會產生任何花費。等到以後需要再從 Snapshot 重新建一台 Server 回來用就好。
能夠以使用時數計費，還有價格相對於 Linode 便宜，是我選擇 DigitalOcean 的原因。
Ref[1]: DigitalOcean 與 Linode 的比較…
Ref[2]: Linode vs DigitalOcean, performance benchmarks
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-04-10-digitalocean/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-03-27-boost-unit-test-framework-in-uva-online-judge/">Boost Unit Test Framework in UVa Online Judge
</a>
</h2>

  <time datetime="2013-03-27">27 Mar, 2013</time>

</div>

  <p class="container content">
  
  
    利用 Boost Unit Test Framework，可以方便的進行單元測試。 而在 UVa Online Judge 的練習中，我們也可以導入 Boost Unit Test Framework 來對我們寫的 function 進行測試。 不過 UVa Online Judge 的編譯環境是不支援 Boost 的，但在編譯時，它會給一個特別的編譯參數 -DONLINE_JUDGE。 所以我們可以利用Uva 這個特有的編譯參數，在導入 Boost Unit Test Framework 時，又不會發生Compiler Error.
單元測試時：
$ g++ 530.cpp -lboost_unit_test_framework $ ./a.out Running 2 test cases... *** No errors detected  以測資做為輸入的測試：
$ g++ 530.cpp -DONLINE_JUDGE $ ./a.out &lt;input.txt 6 252 13983816  程式碼：
//============================================================================ // Name : 530.cpp // Author : // Version : // Copyright : copyright notice //============================================================================ #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;string&gt; using namespace std; #ifndef ONLINE_JUDGE #define BOOST_TEST_DYN_LINK #define BOOST_TEST_MODULE acm #include &lt;boost/test/unit_test.
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-03-27-boost-unit-test-framework-in-uva-online-judge/">Read more &rarr;</a>

</div>


</article>

  
    <article class="container content summary">
  <div class="container hat">
  <h2><a href="https://swem.github.io/post/2013-03-14-rip/">RIP, Google Reader
</a>
</h2>

  <time datetime="2013-03-14">14 Mar, 2013</time>

</div>

  <p class="container content">
  
  
    今天 Google 宣布了 Google Reader 將於 2013/7/1 結束運作。
另一個 RSS 訂閱服務 Feedly 則馬上做出了回應， Feedly 這項服務提供 Google Reader 使用者連結自己所訂閱的 RSS, 並以 Feedly 較為活潑清爽的版面來進行閱讀。 於 Feedly 上連結 Google Reader 的使用者，將可以在 2013/7/1 後，無痛延續閱讀自己訂閱的 RSS 來源.
就我先前的經驗來說，Feedly是個有趣的閱讀介面， 雖然我比較喜歡簡單的閱讀介面，所以還是維持使用 Google Reader, 不過既然現在 Feedly 提供這樣的服務(事實上提供Google Reader的連結訂閱，一直是Feedly的主力服務)， 我想就開始使用看看吧。
有興趣的人可以到: Feedly
Ref:
1. A second spring of cleaning 2. Powering Down Google Reader 3. Transitioning from Google Reader to feedly 
  


</p>


  <div class="container readlink">
  <a href="https://swem.github.io/post/2013-03-14-rip/">Read more &rarr;</a>

</div>


</article>

  
  
<div class="container pagination">
  


<a aria-label="First" href="https://swem.github.io//">
  <span aria-hidden="true">««</span>
</a>

<a aria-label="Previous" href="https://swem.github.io//page/8/">
  <span aria-hidden="true">«</span>
</a>


<a href="https://swem.github.io//">
  1
</a>

<a href="https://swem.github.io//page/2/">
  2
</a>

<a href="https://swem.github.io//page/3/">
  3
</a>

<a href="https://swem.github.io//page/4/">
  4
</a>

<a href="https://swem.github.io//page/5/">
  5
</a>

<a href="https://swem.github.io//page/6/">
  6
</a>

<a href="https://swem.github.io//page/7/">
  7
</a>

<a href="https://swem.github.io//page/8/">
  8
</a>

<a class="active" href="https://swem.github.io//page/9/">
  9
</a>

<a href="https://swem.github.io//page/10/">
  10
</a>


<a aria-label="Next" href="https://swem.github.io//page/10/">
  <span aria-hidden="true">»</span>
</a>

<a aria-label="Last" href="https://swem.github.io//page/10/">
  <span aria-hidden="true">»»</span>
</a>


</div>


</section>

      <footer id="main-footer" class="container main_footer">
  

  <div class="container nav foot no-print">
  

  <a class="toplink" href="#">back to top</a>

</div>

  <div class="container credits">
  

  

</div>

</footer>

    </main>
    


<script src="https://swem.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


    
  </body>
</html>

